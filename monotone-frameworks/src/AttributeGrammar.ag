{
import Data.Graph

import Data.Set (Set(..))
import qualified Data.Set as S

import Data.List

import Data.Monoid

import Control.Monad
}

data Program
  | Program   procs :: Procs
              stat  :: Stat
  deriving Program : Show

data Program'
  | Program'  procs :: Procs'
              stat  :: Stat'
  deriving Program' : Show

type Procs  = [ Proc  ]
type Procs' = [ Proc' ]
data Proc
  | Proc          name :: String  inp :: {[String]}  out :: String   stat :: Stat
  deriving Proc : Show

data Proc'
  | Proc'         labelEntry :: Int  labelReturn :: Int    name :: String  inp :: {[String]}  out :: String   stat :: Stat'
  deriving Proc' : Show

data Stat
  | Skip
  | IfThenElse    cond  :: {BExpr} stat1  :: Stat    stat2 :: Stat
  | While         cond  :: {BExpr} stat   :: Stat
  | Call          name  :: String  params :: {Exprs} out :: String
  | IAssign       name  :: String  val    :: {IExpr}
  | BAssign       name  :: String  val    :: {BExpr}
  | Seq           stat1 :: Stat    stat2  :: Stat
  | Malloc        name  :: String  size   :: {IExpr}
  | Free          ptr   :: {IExpr}
  | RefAssign     ptr   :: {IExpr} val    :: {IExpr}
  | Continue
  | Break
  deriving Stat : Show

data Stat'
  | Skip'          label     :: Int
  | IfThenElse'    labelc    :: Int   cond      :: BExpr   stat1  :: Stat'  stat2  :: Stat'
  | While'         labelc    :: Int   cond      :: BExpr   stat   :: Stat'
  | Call'          labelCall :: Int   labelExit :: Int     name   :: String params :: Exprs  out :: String
  | IAssign'       label     :: Int   name      :: String  val    :: IExpr
  | BAssign'       label     :: Int   name      :: String  val    :: BExpr
  | Seq'           stat1     :: Stat' stat2     :: Stat'
  | Malloc'        label     :: Int   name      :: String  size   :: IExpr
  | Free'          label     :: Int   ptr       :: IExpr
  | RefAssign'     label     :: Int   ptr       :: IExpr   val    :: IExpr
  | Continue'      label     :: Int
  | Break'         label     :: Int
  deriving Stat' : Show

data IExpr
  | IConst        val  :: Int
  | Var           name :: String
  | Plus          left :: IExpr  right :: IExpr
  | Minus         left :: IExpr  right :: IExpr
  | Times         left :: IExpr  right :: IExpr
  | Divide        left :: IExpr  right :: IExpr
  | Deref         ptr  :: IExpr
  deriving IExpr : Eq, Show

data BExpr
  | BConst        val  :: Bool
  | BVar          name :: String
  | LessThan      left :: IExpr  right :: IExpr
  | GreaterThan   left :: IExpr  right :: IExpr
  | LessEqual     left :: IExpr  right :: IExpr
  | GreaterEqual  left :: IExpr  right :: IExpr
  | IEqual        left :: IExpr  right :: IExpr
  | BEqual        left :: BExpr  right :: BExpr
  | And           left :: BExpr  right :: BExpr
  | Or            left :: BExpr  right :: BExpr
  | Not           val  :: BExpr
  deriving BExpr : Eq, Show

type Exprs  = [ Expr  ]
data Expr
  | B BExpr
  | I IExpr
  deriving Expr : Eq, Show

data Code
  | CBExpr   BExpr
  | CIExpr   IExpr
  | CStat    Stat'
  | CProc    Proc'
  | CProgram Program'

--------------------------------------------------------------------------------
--                        1. Handige type-verzamelingen                       --
--------------------------------------------------------------------------------

set Labelable  =
  Procs  Proc  Stat

--------------------------------------------------------------------------------
--                           2. Attribuutdeclaraties                          --
--------------------------------------------------------------------------------

{- label : Int
 -
 - Houdt de huidige beschikbare label-waarde. Dit betekent dus dat de georven
 - waarde altijd gebruikt kan worden, maar moet worden aangepast voordat deze
 - doorgegeven wordt aan de kinderen:
 -
 - vb.
 -
 -  Label 9 komt binnen
 -  Ik gebruik label 9 in een programmapunt
 -  De labelwaarde die ik door ga geven is 9 + 1 = 10.
 -
 - ---------------------------------------------------------------------------
 -
 - cfg : Graph
 -
 - 'Control flow graph' is een synthetisch attribuut op het hoogste niveau. Dit
 - kan triviaal gedaan worden met de verzameling kanten die de stroming
 - definieren: cfg : Set Edges -> Graph
 -
 -}
{
type Label = Int
}

attr Labelable
  chn label :: Label
  -- chn edges :: Set Edge

attr Program
  syn transformed :: Program'
  syn cfg         :: Graph

attr Proc Procs
  syn transformed use {mplus} {mzero} :: Procs'

attr Stat
  syn transformed :: Stat'

{- Alleen de types die een accent-versie hebben krijgen het transformed
 - attribuut omdat daar labels aan verbonden moeten worden.
 -}

{
type Init   =  Label
type Finals = [Label]
}

{- Het labelnummer van de allereerste statement in een programma. -}
attr Program' Stat'
  syn init        :: Init
  syn finals      :: {Finals}

attr Stat'
  syn breakFinals use {mplus} {mzero} :: {Finals} -- Check if a while statement contains a 'Break'.

--------------------------------------------------------------------------------
--                                3. Semantiek                                --
--------------------------------------------------------------------------------

sem Program
  | Program
    lhs.transformed = Program' @procs.transformed @stat.transformed
       .cfg         = let allEdges = S.toList (S.union undefined undefined) -- @stat.edges @procs.edges)
                      in buildG (findBounds allEdges) allEdges
    procs.label     = 1
    stat.label      = @procs.label

sem Proc
  | Proc
    loc.entry :: uniqueref label
       .exit  :: uniqueref label
    lhs.transformed =
      return (Proc' @loc.entry @loc.exit @name @inp @out @stat.transformed)

sem Stat
  | Skip IfThenElse While Call IAssign BAssign Seq Malloc Free RefAssign
    Continue Break
    loc.nextLabel :: uniqueref label

sem Stat
  | Skip       lhs.transformed = Skip' @loc.nextLabel
  | IfThenElse lhs.transformed = IfThenElse' @loc.nextLabel @cond @stat1.transformed @stat2.transformed
  | While      lhs.transformed = While'      @loc.nextLabel @cond @stat.transformed
  | IAssign    lhs.transformed = IAssign'    @loc.nextLabel @name @val
  | BAssign    lhs.transformed = BAssign'    @loc.nextLabel @name @val
  | Seq        lhs.transformed = Seq'        @stat1.transformed @stat2.transformed
  | Malloc     lhs.transformed = Malloc'     @loc.nextLabel @name @size
  | Free       lhs.transformed = Free'       @loc.nextLabel @ptr
  | RefAssign  lhs.transformed = RefAssign'  @loc.nextLabel @ptr @val
  | Continue   lhs.transformed = Continue'   @loc.nextLabel
  | Break      lhs.transformed = Break'      @loc.nextLabel
  | Call       loc.call   :: uniqueref label
                  .return :: uniqueref label
               lhs.transformed = Call'       @loc.call @loc.return @name @params @out

sem Program'
  | Program'
    lhs.init   = @stat.init
       .finals = @stat.finals

sem Stat'
  | Skip'
    lhs.init        = @label
       .finals      = return @label
  | IfThenElse'
    lhs.init        = @labelc
       .finals      = @stat1.finals `mplus` @stat2.finals
  | While'
    lhs.init        = @labelc
       .finals      = (return @labelc) `mplus` @stat.breakFinals
  | Call'
    lhs.init        = @labelCall
       .finals      = return @labelExit
  | IAssign'
    lhs.init        = @label
       .finals      = return @label
  | BAssign'
    lhs.init        = @label
       .finals      = return @label
  | Seq'
    lhs.init        = @stat1.init
       .finals      = @stat2.finals
       .breakFinals = @stat1.breakFinals `mplus` @stat2.breakFinals
  | Malloc'
    lhs.init        = @label
       .finals      = return @label
  | Free'
    lhs.init        = @label
       .finals      = return @label
  | RefAssign'
    lhs.init        = @label
       .finals      = return @label
  | Continue'
    lhs.init        = @label
       .finals      = return @label
  | Break'
    lhs.init        = @label
       .finals      = return @label
       .breakFinals = return @label

--------------------------------------------------------------------------------
--                               4. Hulpfuncties                              --
--------------------------------------------------------------------------------

{

{- Labelgenerator. Deze functie verzorgt het genereren van verse
 - programmapunten, dat wordt ons volledig uit handen genomen door het AG
 - systeem.
 -
 - Let wel: Labels worden altijd gegenereerd, maar niet altijd gebruikt. Het kan
 - dus zijn dat de getallen 1 t/m 10 gegenereerd worden als labels maar dat
 - uiteindelijk alleen 3,4 en 5 gebruikt worden. Dan mist de rest dus, maar dat
 - maakt niet uit.
 -}
nextUnique :: Label -> (Label, Label)
nextUnique u = (u + 1, u)

-- Vind de grenzen van de control flow graaf
findBounds :: [Edge] -> (Int, Int)
findBounds edges =
  let xs = foldl' (\cur (x, y) -> x:y:cur) [] edges
  in (minimum xs, maximum xs)
}
