
imports {
import Utils.Similarity ( similar )
import Main.Args
import Syntax.UHA_Syntax
import Syntax.UHA_Utils
import Syntax.UHA_Range
import Types

--import Utils.StaticErrors
import Utils.Warnings
import Utils.Messages
import Data.List
import Utils.Utils

import qualified Data.Map as M
import qualified Data.Set as S
import Data.Set (Set)

import ModuleSystem.ImportEnvironment
import Parser.OperatorTable
import Data.Char ( isUpper )

}

INCLUDE "UHA_Syntax.ag"

ATTR Module
   [ baseName              : String
     importEnvironments    : ImportEnvironments
   |
   | collectEnvironment    : ImportEnvironment
     errors                : Errors
     typeSignatures        : {[(Name,TpScheme)]}
     warnings              : Warnings
   ]

ATTR Module Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems [ | | nrOfLeaves USE {(+)} {1} : Int ]

-- Opgave B, letDepth
ATTR Module Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems [ | | letDepth USE {(+)} {0} : Int ]

-- Opgave C, reservedWords
ATTR Module Body Declarations Declaration Fixity Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems ImportDeclaration [ | | reservedWords USE {(++)}  {[]} : {[String]} ]

-- Opgave D, list of type classes
ATTR Module Body Declarations Declaration
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives
     FunctionBinding FunctionBindings
     RightHandSide MaybeDeclarations
     [ | | usedInstances USE {S.union} {S.empty} : {Set String}]

ATTR Module Body Declarations Declaration
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives
     FunctionBinding FunctionBindings
     RightHandSide MaybeDeclarations
     [ | | definedClasses USE {S.union} {S.empty} : {Set String}]

ATTR Module [ | | emptyClasses : {Set String} ]

ATTR SimpleType Name [ | | stname : String ]

-- Opgave E, multiple type declarations
ATTR Module Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems [ | | typeDecls USE {(++)} {[]} : {[(String,[(String,Int)])]} ]



SEM Module
   | Module     lhs.errors   = []
                   .warnings = []
                   .typeSignatures = []
                   .collectEnvironment = head (@lhs.importEnvironments)
                   .emptyClasses = @body.definedClasses `S.difference` @body.usedInstances

SEM Declarations
  | Cons lhs.letDepth = max @hd.letDepth @tl.letDepth

SEM Expressions
  | Cons lhs.letDepth = max @hd.letDepth @tl.letDepth

-- Opgave A
SEM Declaration
  | Class     lhs.nrOfLeaves = 0
                 .definedClasses = S.singleton (@simpletype.stname)
  | Instance  lhs.nrOfLeaves = 0
                 .usedInstances = S.singleton (@name.stname)
                 

-- Opgave B
SEM Expression
  | Let lhs.letDepth = 1 + max @expression.letDepth @declarations.letDepth


SEM SimpleType
  | SimpleType lhs.stname = @name.stname

SEM Name
  | Identifier lhs.stname = @name
  | Operator   lhs.stname = @name
  | Special    lhs.stname = @name

-- Opgave C

SEM Module
   | Module   lhs.reservedWords = "module" : "where" : (@body.reservedWords)

ATTR MaybeName [ | | reservedWordsAs USE {(++)} {[]} : {[String]} ]

SEM MaybeName
   | Nothing  lhs.reservedWordsAs = []
   | Just     lhs.reservedWordsAs = ["as"]

SEM ImportDeclaration
   | Import   lhs.reservedWords = "import" : (if @qualified then ["qualified"] else []) ++ (@asname.reservedWordsAs) --TODO hiding

SEM Declaration
   | Type     lhs.reservedWords = "type" : (@type.reservedWords)
   | Data     lhs.reservedWords = "data" : (@context.reservedWords) ++ (@constructors.reservedWords) -- ++ (case @derivings of [] -> []; _ -> ["deriving"]) --TODO. Can't figure out how to pattern match on those lists. UUAGC docs are down atm.
   | Newtype  lhs.reservedWords = "newtype" : (@context.reservedWords) ++ (@constructor.reservedWords) -- ++ (@derivings.reservedWordsDerivings)
   | Class    lhs.reservedWords = "class" : (@context.reservedWords) ++ (@where.reservedWords)
   | Instance lhs.reservedWords = "instance" : (@context.reservedWords) ++ (@types.reservedWords) ++ (@where.reservedWords)
   | Hole     lhs.reservedWords = ["_"]
   | Default  lhs.reservedWords = "default" : @types.reservedWords

SEM Fixity
   | Infixl   lhs.reservedWords = ["infixl"]
   | Infixr   lhs.reservedWords = ["infixr"]
   | Infix    lhs.reservedWords = ["infix"]

SEM MaybeDeclarations
   | Nothing  lhs.reservedWords = []
   | Just     lhs.reservedWords = "where" : (@declarations.reservedWords)

SEM Expression
   | Hole     lhs.reservedWords = ["_"]
   | If       lhs.reservedWords = "if" : @guardExpression.reservedWords ++ "then" : @thenExpression.reservedWords ++ "else" : @elseExpression.reservedWords
   | Case     lhs.reservedWords = "case" : @expression.reservedWords ++ "of" : @alternatives.reservedWords
   | Do       lhs.reservedWords = "do" : @statements.reservedWords
   | Let      lhs.reservedWords = "let" : @declarations.reservedWords ++ "in" : @expression.reservedWords

-- Opgave E

ATTR SimpleType [ | | decls : {(String, [(String,Int)])} ]

ATTR Range Position [ | | info : {[(String,Int)]} ]

SEM Position
   | Position   lhs.info = [(@filename, @line)]
   | Unknown    lhs.info = []

SEM Range
   | Range      lhs.info = @start.info

SEM SimpleType
   | SimpleType lhs.decls = (@name.stname, @range.info)

SEM Declaration
   | Type       lhs.typeDecls = [@simpletype.decls]

SEM Module
   | Module     lhs.typeDecls = M.toList $ M.filter ((>1) . length) $ foldr (uncurry $ M.insertWith (++)) M.empty @body.typeDecls

{
data Rosetree a = Node a [Rosetree a]
  deriving Show

instance Functor Rosetree where
  fmap f (Node a ns) = Node (f a) (map (fmap f) ns)
}

-- Opgave F
ATTR Module Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems [ level : Int | | variables USE {(++)} {[]} : {[(String,Int)]} ]
                                                                      

SEM Module
  | Module    body.level = 0
              lhs.level  = 0

SEM Body
  | Body      declarations.level       = @lhs.level + 1
              importdeclarations.level = @lhs.level + 1

SEM Declarations
  | Cons      hd.level = @lhs.level
              tl.level = @lhs.level

SEM ImportDeclarations
  | Cons      hd.level = @lhs.level
              tl.level = @lhs.level

SEM Declaration
  | Class            context.level       = @lhs.level + 1
                     where.level         = @lhs.level + 1
  | Instance         context.level       = @lhs.level + 1
                     where.level         = @lhs.level + 1
  | FunctionBindings bindings.level      = @lhs.level + 1
  | PatternBinding   pattern.level       = @lhs.level + 1
                     righthandside.level = @lhs.level + 1

SEM ImportDeclaration
  | Import     importspecification.level = @lhs.level

SEM ContextItems
  | Cons       hd.level = @lhs.level
               tl.level = @lhs.level

SEM MaybeDeclarations
  | Just       declarations.level = @lhs.level

SEM FunctionBindings
  | Cons       hd.level = @lhs.level
               tl.level = @lhs.level

SEM Patterns
  | Cons       hd.level = @lhs.level
               tl.level = @lhs.level

SEM Pattern
  | Constructor       patterns.level     = @lhs.level + 1
  | Parenthesized     pattern.level      = @lhs.level + 1
  | InfixConstructor  leftPattern.level  = @lhs.level + 1
                      rightPattern.level = @lhs.level + 1
  | List              patterns.level     = @lhs.level + 1
  | Tuple             patterns.level     = @lhs.level + 1
  | Record            recordPatternBindings.level = @lhs.level + 1
  | As                pattern.level      = @lhs.level + 1
  | Irrefutable       pattern.level      = @lhs.level + 1

SEM RightHandSide
  | Expression        expression.level   = @lhs.level + 1
                      where.level        = @lhs.level + 1
  | Guarded           guardedexpressions.level = @lhs.level + 1
                      where.level        = @lhs.level + 1